# Code analysis
## java-sec-code 
#### Version 1.0.0 

**By: Administrator**

*Date: 2023-05-05*

## Introduction
This document contains results of the code analysis of java-sec-code

Parent pom providing dependency and plugin management for applications
		built with Maven

## Configuration

- Quality Profiles
    - Names: Sonar way [Java]; Sonar way [XML]; 
    - Files: AYfdNv8hhgrDms8oyRZE.json; AYfdNwE1hgrDms8oyRis.json; 


 - Quality Gate
    - Name: Sonar way
    - File: Sonar way.xml

## Synthesis

### Analysis Status

Reliability | Security | Security Review | Maintainability |
:---:|:---:|:---:|:---:
E | E | E | A |

### Quality gate status

| Quality Gate Status | OK |
|-|-|



### Metrics

Coverage | Duplications | Comment density | Median number of lines of code per file | Adherence to coding standard |
:---:|:---:|:---:|:---:|:---:
0.0 % | 1.2 % | 14.1 % | 35.0 | 96.9 %

### Tests

Total | Success Rate | Skipped | Errors | Failures |
:---:|:---:|:---:|:---:|:---:
0 | 0 % | 0 | 0 | 0

### Detailed technical debt

Reliability|Security|Maintainability|Total
---|---|---|---
0d 2h 25min|0d 4h 45min|5d 5h 33min|6d 4h 43min


### Metrics Range

\ | Cyclomatic Complexity | Cognitive Complexity | Lines of code per file | Coverage | Comment density (%) | Duplication (%)
:---|:---:|:---:|:---:|:---:|:---:|:---:
Min | 0.0 | 0.0 | 0.0 | 0.0 | 0.0 | 0.0
Max | 517.0 | 418.0 | 4033.0 | 0.0 | 100.0 | 28.6

### Volume

Language|Number
---|---
Java|4033
XML|280
Total|4313


## Issues

### Issues count by severity and types

Type / Severity|INFO|MINOR|MAJOR|CRITICAL|BLOCKER
---|---|---|---|---|---
BUG|0|1|5|0|13
VULNERABILITY|0|0|0|0|13
CODE_SMELL|1|124|170|47|2


### Issues List

Name|Description|Type|Severity|Number
---|---|---|---|---
Resources should be closed|Connections, streams, files, and other classes that implement the Closeable interface or its super-interface, <br /> AutoCloseable, needs to be closed after use. Further, that close call must be made in a finally block otherwise <br /> an exception could keep the call from being made. Preferably, when class implements AutoCloseable, resource should be created using <br /> "try-with-resources" pattern and will be closed automatically. <br /> Failure to properly close resources will result in a resource leak which could bring first the application and then perhaps the box the application <br /> is on to their knees. <br /> Noncompliant Code Example <br />  <br /> private void readTheFile() throws IOException { <br />   Path path = Paths.get(this.fileName); <br />   BufferedReader reader = Files.newBufferedReader(path, this.charset); <br />   // ... <br />   reader.close();  // Noncompliant <br />   // ... <br />   Files.lines("input.txt").forEach(System.out::println); // Noncompliant: The stream needs to be closed <br /> } <br />  <br /> private void doSomething() { <br />   OutputStream stream = null; <br />   try { <br />     for (String property : propertyList) { <br />       stream = new FileOutputStream("myfile.txt");  // Noncompliant <br />       // ... <br />     } <br />   } catch (Exception e) { <br />     // ... <br />   } finally { <br />     stream.close();  // Multiple streams were opened. Only the last is closed. <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> private void readTheFile(String fileName) throws IOException { <br />     Path path = Paths.get(fileName); <br />     try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) { <br />       reader.readLine(); <br />       // ... <br />     } <br />     // .. <br />     try (Stream&lt;String&gt; input = Files.lines("input.txt"))  { <br />       input.forEach(System.out::println); <br />     } <br /> } <br />  <br /> private void doSomething() { <br />   OutputStream stream = null; <br />   try { <br />     stream = new FileOutputStream("myfile.txt"); <br />     for (String property : propertyList) { <br />       // ... <br />     } <br />   } catch (Exception e) { <br />     // ... <br />   } finally { <br />     stream.close(); <br />   } <br /> } <br />  <br /> Exceptions <br /> Instances of the following classes are ignored by this rule because close has no effect: <br />  <br />    java.io.ByteArrayOutputStream  <br />    java.io.ByteArrayInputStream  <br />    java.io.CharArrayReader  <br />    java.io.CharArrayWriter  <br />    java.io.StringReader  <br />    java.io.StringWriter  <br />  <br /> Java 7 introduced the try-with-resources statement, which implicitly closes Closeables. All resources opened in a try-with-resources <br /> statement are ignored by this rule. <br />  <br /> try (BufferedReader br = new BufferedReader(new FileReader(fileName))) { <br />   //... <br /> } <br /> catch ( ... ) { <br />   //... <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-459 - Incomplete Cleanup  <br />    MITRE, CWE-772 - Missing Release of Resource after Effective Lifetime  <br />    CERT, FIO04-J. - Release resources when they are no longer needed  <br />    CERT, FIO42-C. - Close files when they are no longer needed  <br />    Try With Resources  <br /> |BUG|BLOCKER|13
"InterruptedException" should not be ignored|InterruptedExceptions should never be ignored in the code, and simply logging the exception counts in this case as "ignoring". The <br /> throwing of the InterruptedException clears the interrupted state of the Thread, so if the exception is not handled properly the <br /> information that the thread was interrupted will be lost. Instead, InterruptedExceptions should either be rethrown - immediately or after <br /> cleaning up the methodâ€™s state - or the thread should be re-interrupted by calling Thread.interrupt() even if this is supposed to be a <br /> single-threaded application. Any other course of action risks delaying thread shutdown and loses the information that the thread was interrupted - <br /> probably without finishing its task. <br /> Similarly, the ThreadDeath exception should also be propagated. According to its JavaDoc: <br />  <br />   If ThreadDeath is caught by a method, it is important that it be rethrown so that the thread actually dies. <br />  <br /> Noncompliant Code Example <br />  <br /> public void run () { <br />   try { <br />     while (true) { <br />       // do stuff <br />     } <br />   }catch (InterruptedException e) { // Noncompliant; logging is not enough <br />     LOGGER.log(Level.WARN, "Interrupted!", e); <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void run () { <br />   try { <br />     while (true) { <br />       // do stuff <br />     } <br />   }catch (InterruptedException e) { <br />     LOGGER.log(Level.WARN, "Interrupted!", e); <br />     // Restore interrupted state... <br />     Thread.currentThread().interrupt(); <br />   } <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-391 - Unchecked Error Condition  <br /> |BUG|MAJOR|5
Math operands should be cast before assignment|When arithmetic is performed on integers, the result will always be an integer. You can assign that result to a long, <br /> double, or float with automatic type conversion, but having started as an int or long, the result <br /> will likely not be what you expect. <br /> For instance, if the result of int division is assigned to a floating-point variable, precision will have been lost before the <br /> assignment. Likewise, if the result of multiplication is assigned to a long, it may have already overflowed before the assignment. <br /> In either case, the result will not be what was expected. Instead, at least one operand should be cast or promoted to the final type before the <br /> operation takes place. <br /> Noncompliant Code Example <br />  <br /> float twoThirds = 2/3; // Noncompliant; int division. Yields 0.0 <br /> long millisInYear = 1_000*3_600*24*365; // Noncompliant; int multiplication. Yields 1471228928 <br /> long bigNum = Integer.MAX_VALUE + 2; // Noncompliant. Yields -2147483647 <br /> long bigNegNum =  Integer.MIN_VALUE-1; //Noncompliant, gives a positive result instead of a negative one. <br /> Date myDate = new Date(seconds * 1_000); //Noncompliant, won't produce the expected result if seconds &gt; 2_147_483 <br /> ... <br /> public long compute(int factor){ <br />   return factor * 10_000;  //Noncompliant, won't produce the expected result if factor &gt; 214_748 <br /> } <br />  <br /> public float compute2(long factor){ <br />   return factor / 123;  //Noncompliant, will be rounded to closest long integer <br /> } <br />  <br /> Compliant Solution <br />  <br /> float twoThirds = 2f/3; // 2 promoted to float. Yields 0.6666667 <br /> long millisInYear = 1_000L*3_600*24*365; // 1000 promoted to long. Yields 31_536_000_000 <br /> long bigNum = Integer.MAX_VALUE + 2L; // 2 promoted to long. Yields 2_147_483_649 <br /> long bigNegNum =  Integer.MIN_VALUE-1L; // Yields -2_147_483_649 <br /> Date myDate = new Date(seconds * 1_000L); <br /> ... <br /> public long compute(int factor){ <br />   return factor * 10_000L; <br /> } <br />  <br /> public float compute2(long factor){ <br />   return factor / 123f; <br /> } <br />  <br /> or <br />  <br /> float twoThirds = (float)2/3; // 2 cast to float <br /> long millisInYear = (long)1_000*3_600*24*365; // 1_000 cast to long <br /> long bigNum = (long)Integer.MAX_VALUE + 2; <br /> long bigNegNum =  (long)Integer.MIN_VALUE-1; <br /> Date myDate = new Date((long)seconds * 1_000); <br /> ... <br /> public long compute(long factor){ <br />   return factor * 10_000; <br /> } <br />  <br /> public float compute2(float factor){ <br />   return factor / 123; <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-190 - Integer Overflow or Wraparound  <br />    CERT, NUM50-J. - Convert integers to floating point for floating-point operations <br />    <br />    CERT, INT18-C. - Evaluate integer expressions in a larger size before comparing or <br />   assigning to that size  <br />    SANS Top 25 - Risky Resource Management  <br /> |BUG|MINOR|1
Methods and field names should not be the same or differ only by capitalization|Looking at the set of methods in a class, including superclass methods, and finding two methods or fields that differ only by capitalization is <br /> confusing to users of the class. It is similarly confusing to have a method and a field which differ only in capitalization or a method and a field <br /> with exactly the same name and visibility. <br /> In the case of methods, it may have been a mistake on the part of the original developer, who intended to override a superclass method, but instead <br /> added a new method with nearly the same name. <br /> Otherwise, this situation simply indicates poor naming. Method names should be action-oriented, and thus contain a verb, which is unlikely in the <br /> case where both a method and a member have the same name (with or without capitalization differences). However, renaming a public method could be <br /> disruptive to callers. Therefore renaming the member is the recommended action. <br /> Noncompliant Code Example <br />  <br /> public class Car{ <br />  <br />   public DriveTrain drive; <br />  <br />   public void tearDown(){...} <br />  <br />   public void drive() {...}  // Noncompliant; duplicates field name <br /> } <br />  <br /> public class MyCar extends Car{ <br />   public void teardown(){...}  // Noncompliant; not an override. It it really what's intended? <br />  <br />   public void drivefast(){...} <br />  <br />   public void driveFast(){...} //Huh? <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Car{ <br />  <br />   private DriveTrain drive; <br />  <br />   public void tearDown(){...} <br />  <br />   public void drive() {...}  // field visibility reduced <br /> } <br />  <br /> public class MyCar extends Car{ <br />   @Override <br />   public void tearDown(){...} <br />  <br />   public void drivefast(){...} <br />  <br />   public void driveReallyFast(){...} <br />  <br /> } <br /> |CODE_SMELL|BLOCKER|2
Constant names should comply with a naming convention|Shared coding conventions allow teams to collaborate efficiently. This rule checks that all constant names match a provided regular expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$: <br />  <br /> public class MyClass { <br />   public static final int first = 1; <br /> } <br />  <br /> public enum MyEnum { <br />   first; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyClass { <br />   public static final int FIRST = 1; <br /> } <br />  <br /> public enum MyEnum { <br />   FIRST; <br /> } <br /> |CODE_SMELL|CRITICAL|1
Methods should not be empty|There are several reasons for a method not to have a method body: <br />  <br />    It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production.  <br />    It is not yet, or never will be, supported. In this case an UnsupportedOperationException should be thrown.  <br />    The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override.  <br />  <br /> Noncompliant Code Example <br />  <br /> public void doSomething() { <br /> } <br />  <br /> public void doSomethingElse() { <br /> } <br />  <br /> Compliant Solution <br />  <br /> @Override <br /> public void doSomething() { <br />   // Do nothing because of X and Y. <br /> } <br />  <br /> @Override <br /> public void doSomethingElse() { <br />   throw new UnsupportedOperationException(); <br /> } <br />  <br /> Exceptions <br /> This does not raise an issue in the following cases: <br />  <br />    Non-public default (no-argument) constructors  <br />    Public default (no-argument) constructors when there are other constructors in the class  <br />    Empty methods in abstract classes  <br />    Methods annotated with @org.aspectj.lang.annotation.Pointcut()  <br />  <br />  <br /> public abstract class Animal { <br />   void speak() {  // default implementation ignored <br />   } <br /> } <br /> |CODE_SMELL|CRITICAL|11
String literals should not be duplicated|Duplicated string literals make the process of refactoring error-prone, since you must be sure to update all occurrences. <br /> On the other hand, constants can be referenced from many places, but only need to be updated in a single place. <br /> Noncompliant Code Example <br /> With the default threshold of 3: <br />  <br /> public void run() { <br />   prepare("action1");                              // Noncompliant - "action1" is duplicated 3 times <br />   execute("action1"); <br />   release("action1"); <br /> } <br />  <br /> @SuppressWarning("all")                            // Compliant - annotations are excluded <br /> private void method1() { /* ... */ } <br /> @SuppressWarning("all") <br /> private void method2() { /* ... */ } <br />  <br /> public String method3(String a) { <br />   System.out.println("'" + a + "'");               // Compliant - literal "'" has less than 5 characters and is excluded <br />   return "";                                       // Compliant - literal "" has less than 5 characters and is excluded <br /> } <br />  <br /> Compliant Solution <br />  <br /> private static final String ACTION_1 = "action1";  // Compliant <br />  <br /> public void run() { <br />   prepare(ACTION_1);                               // Compliant <br />   execute(ACTION_1); <br />   release(ACTION_1); <br /> } <br />  <br /> Exceptions <br /> To prevent generating some false-positives, literals having less than 5 characters are excluded.|CODE_SMELL|CRITICAL|19
Instance methods should not write to "static" fields|Correctly updating a static field from a non-static method is tricky to get right and could easily lead to bugs if there are multiple <br /> class instances and/or multiple threads in play. Ideally, static fields are only updated from synchronized static <br /> methods. <br /> This rule raises an issue each time a static field is updated from a non-static method. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />  <br />   private static int count = 0; <br />  <br />   public void doSomething() { <br />     //... <br />     count++;  // Noncompliant <br />   } <br /> } <br /> |CODE_SMELL|CRITICAL|12
"static" base class members should not be accessed via derived types|In the interest of code clarity, static members of a base class should never be accessed using a derived typeâ€™s name. <br /> Doing so is confusing and could create the illusion that two different static members exist. <br /> Noncompliant Code Example <br />  <br /> class Parent { <br />   public static int counter; <br /> } <br />  <br /> class Child extends Parent { <br />   public Child() { <br />     Child.counter++;  // Noncompliant <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> class Parent { <br />   public static int counter; <br /> } <br />  <br /> class Child extends Parent { <br />   public Child() { <br />     Parent.counter++; <br />   } <br /> } <br /> |CODE_SMELL|CRITICAL|2
Cognitive Complexity of methods should not be too high|Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be <br /> difficult to maintain. <br /> Exceptions <br /> equals and hashCode methods are ignored because they might be automatically generated and might end up being difficult to <br /> understand, especially in presence of many fields. <br /> See <br />  <br />    Cognitive Complexity  <br /> |CODE_SMELL|CRITICAL|2
Deprecated code should be removed|This rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed. <br /> Noncompliant Code Example <br />  <br /> class Foo { <br />   /** <br />    * @deprecated <br />    */ <br />   public void foo() {    // Noncompliant <br />   } <br />  <br />   @Deprecated            // Noncompliant <br />   public void bar() { <br />   } <br />  <br />   public void baz() {    // Compliant <br />   } <br /> } <br /> |CODE_SMELL|INFO|1
Standard outputs should not be used directly to log anything|When logging a message there are several important requirements which must be fulfilled: <br />  <br />    The user must be able to easily retrieve the logs  <br />    The format of all logged message must be uniform to allow the user to easily read the log  <br />    Logged data must actually be recorded  <br />    Sensitive data must only be logged securely  <br />  <br /> If a program directly writes to the standard outputs, there is absolutely no way to comply with those requirements. Thatâ€™s why defining and using a <br /> dedicated logger is highly recommended. <br /> Noncompliant Code Example <br />  <br /> System.out.println("My Message");  // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> logger.log("My Message"); <br />  <br /> See <br />  <br />    OWASP Top 10 2021 Category A9 - Security Logging and <br />   Monitoring Failures  <br />    OWASP Top 10 2017 Category A3 - Sensitive Data <br />   Exposure  <br />    CERT, ERR02-J. - Prevent exceptions while logging data  <br /> |CODE_SMELL|MAJOR|29
Collapsible "if" statements should be merged|Merging collapsible if statements increases the codeâ€™s readability. <br /> Noncompliant Code Example <br />  <br /> if (file != null) { <br />   if (file.isFile() &#124&#124 file.isDirectory()) { <br />     /* ... */ <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> if (file != null &amp;&amp; isFileOrDirectory(file)) { <br />   /* ... */ <br /> } <br />  <br /> private static boolean isFileOrDirectory(File file) { <br />   return file.isFile() &#124&#124 file.isDirectory(); <br /> } <br /> |CODE_SMELL|MAJOR|3
Unused "private" fields should be removed|If a private field is declared but not used in the program, it can be considered dead code and should therefore be removed. This will <br /> improve maintainability because developers will not wonder what the variable is used for. <br /> Note that this rule does not take reflection into account, which means that issues will be raised on private fields that are only <br /> accessed using the reflection API. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />   private int foo = 42; <br />  <br />   public int compute(int a) { <br />     return a * 42; <br />   } <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyClass { <br />   public int compute(int a) { <br />     return a * 42; <br />   } <br /> } <br />  <br /> Exceptions <br /> The rule admits 3 exceptions: <br />  <br />    Serialization id fields  <br />    Annotated fields  <br />    Fields from classes with native methods  <br />  <br /> Serialization id fields <br /> The Java serialization runtime associates with each serializable class a version number, called serialVersionUID, which is used during <br /> deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to <br /> serialization. <br /> A serializable class can declare its own serialVersionUID explicitly by declaring a field named serialVersionUID that <br /> must be static, final, and of type long. By definition those serialVersionUID fields should not be reported by this rule: <br />  <br /> public class MyClass implements java.io.Serializable { <br />   private static final long serialVersionUID = 42L; <br /> } <br />  <br /> Annotated fields <br /> The unused field in this class will not be reported by the rule as it is annotated. <br />  <br /> public class MyClass { <br />   @SomeAnnotation <br />   private int unused; <br /> } <br />  <br /> Fields from classes with native methods <br /> The unused field in this class will not be reported by the rule as it might be used by native code. <br />  <br /> public class MyClass { <br />   private int unused = 42; <br />   private native static void doSomethingNative(); <br /> } <br /> |CODE_SMELL|MAJOR|1
Nested blocks of code should not be left empty|Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed. <br /> Noncompliant Code Example <br />  <br /> for (int i = 0; i &lt; 42; i++){}  // Empty on purpose or missing piece of code ? <br />  <br /> Exceptions <br /> When a block contains a comment, this block is not considered to be empty unless it is a synchronized block. synchronized <br /> blocks are still considered empty even with comments because they can still affect program flow.|CODE_SMELL|MAJOR|5
Local variables should not shadow class fields|Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of <br /> code. Further, it could lead maintainers to introduce bugs because they think theyâ€™re using one variable but are really using another. <br /> Noncompliant Code Example <br />  <br /> class Foo { <br />   public int myField; <br />  <br />   public void doSomething() { <br />     int myField = 0; <br />     ... <br />   } <br /> } <br />  <br /> See <br />  <br />    CERT, DCL01-C. - Do not reuse <br />   variable names in subscopes  <br />    CERT, DCL51-J. - Do <br />   not shadow or obscure identifiers in subscopes  <br /> |CODE_SMELL|MAJOR|4
Utility classes should not have public constructors|Utility classes, which are collections of static members, are not meant to be instantiated. Even abstract utility classes, which can <br /> be extended, should not have public constructors. <br /> Java adds an implicit public constructor to every class which does not define at least one explicitly. Hence, at least one non-public constructor <br /> should be defined. <br /> Noncompliant Code Example <br />  <br /> class StringUtils { // Noncompliant <br />  <br />   public static String concatenate(String s1, String s2) { <br />     return s1 + s2; <br />   } <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> class StringUtils { // Compliant <br />  <br />   private StringUtils() { <br />     throw new IllegalStateException("Utility class"); <br />   } <br />  <br />   public static String concatenate(String s1, String s2) { <br />     return s1 + s2; <br />   } <br />  <br /> } <br />  <br /> Exceptions <br /> When class contains public static void main(String[] args) method it is not considered as utility class and will be ignored by this <br /> rule.|CODE_SMELL|MAJOR|9
Generic exceptions should never be thrown|Using such generic exceptions as Error, RuntimeException, Throwable, and Exception prevents <br /> calling methods from handling true, system-generated exceptions differently than application-generated errors. <br /> Noncompliant Code Example <br />  <br /> public void foo(String bar) throws Throwable {  // Noncompliant <br />   throw new RuntimeException("My Message");     // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void foo(String bar) { <br />   throw new MyOwnRuntimeException("My Message"); <br /> } <br />  <br /> Exceptions <br /> Generic exceptions in the signatures of overriding methods are ignored, because overriding method has to follow signature of the throw declaration <br /> in the superclass. The issue will be raised on superclass declaration of the method (or wonâ€™t be raised at all if superclass is not part of the <br /> analysis). <br />  <br /> @Override <br /> public void myMethod() throws Exception {...} <br />  <br /> Generic exceptions are also ignored in the signatures of methods that make calls to methods that throw generic exceptions. <br />  <br /> public void myOtherMethod throws Exception { <br />   doTheThing();  // this method throws Exception <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-397 - Declaration of Throws for Generic Exception  <br />    CERT, ERR07-J. - Do not throw RuntimeException, Exception, or Throwable  <br /> |CODE_SMELL|MAJOR|5
Deprecated elements should have both the annotation and the Javadoc tag|Deprecation should be marked with both the @Deprecated annotation and @deprecated Javadoc tag. The annotation enables tools such as <br /> IDEs to warn about referencing deprecated elements, and the tag can be used to explain when it was deprecated, why, and how references should be <br /> refactored. <br /> Noncompliant Code Example <br />  <br /> class MyClass { <br />  <br />   @Deprecated <br />   public void foo1() {    // Noncompliant: Add the missing @deprecated Javadoc tag. <br />   } <br />  <br />   /** <br />     * @deprecated <br />     */ <br />   public void foo2() {    // Noncompliant: Add the missing @Deprecated annotation. <br />   } <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />  <br />   /** <br />     * @deprecated (when, why, refactoring advice...) <br />     */ <br />   @Deprecated <br />   public void foo1() { <br />   } <br />  <br /> } <br />  <br /> Exceptions <br /> The members and methods of a deprecated class or interface are ignored by this rule. The classes and interfaces themselves are still subject to <br /> it. <br />  <br /> /** <br />  * @deprecated (when, why, etc...) <br />  */ <br /> @Deprecated <br /> class Qix  { <br />  <br />   public void foo() {} // Compliant; class is deprecated <br />  <br /> } <br />  <br /> /** <br />  * @deprecated (when, why, etc...) <br />  */ <br /> @Deprecated <br /> interface Plop { <br />  <br />   void bar(); <br />  <br /> } <br /> |CODE_SMELL|MAJOR|1
Try-catch blocks should not be nested|Nesting try/catch blocks severely impacts the readability of source code because it makes it too difficult to understand <br /> which block will catch which exception.|CODE_SMELL|MAJOR|2
Sections of code should not be commented out|Programmers should not comment out code as it bloats programs and reduces readability. <br /> Unused code should be deleted and can be retrieved from source control history if required.|CODE_SMELL|MAJOR|8
Anonymous inner classes containing only one method should become lambdas|Before Java 8, the only way to partially support closures in Java was by using anonymous inner classes. But the syntax of anonymous classes may <br /> seem unwieldy and unclear. <br /> With Java 8, most uses of anonymous inner classes should be replaced by lambdas to highly increase the readability of the source code. <br /> Note that this rule is automatically disabled when the projectâ€™s sonar.java.source is lower than 8. <br /> Noncompliant Code Example <br />  <br /> myCollection.stream().map(new Mapper&lt;String,String&gt;() { <br />   public String map(String input) { <br />     return new StringBuilder(input).reverse().toString(); <br />   } <br /> }); <br />  <br /> Predicate&lt;String&gt; isEmpty = new Predicate&lt;String&gt; { <br />     boolean test(String myString) { <br />         return myString.isEmpty(); <br />     } <br /> } <br />  <br /> Compliant Solution <br />  <br /> myCollection.stream().map(input -&gt; new StringBuilder(input).reverse().toString()); <br />  <br /> Predicate&lt;String&gt; isEmpty = myString -&gt; myString.isEmpty(); <br /> |CODE_SMELL|MAJOR|2
Unused assignments should be removed|A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value <br /> only to then overwrite it or throw it away, could indicate a serious error in the code. Even if itâ€™s not an error, it is at best a waste of resources. <br /> Therefore all calculated values should be used. <br /> Noncompliant Code Example <br />  <br /> i = a + b; // Noncompliant; calculation result not used before value is overwritten <br /> i = compute(); <br />  <br /> Compliant Solution <br />  <br /> i = a + b; <br /> i += compute(); <br />  <br /> Exceptions <br /> This rule ignores initializations to -1, 0, 1, null, true, false and "". <br /> See <br />  <br />    MITRE, CWE-563 - Assignment to Variable without Use ('Unused Variable')  <br />    CERT, MSC13-C. - Detect and remove unused values  <br />    CERT, MSC56-J. - Detect and remove superfluous code and values  <br /> |CODE_SMELL|MAJOR|2
Two branches in a conditional structure should not have exactly the same implementation|Having two cases in a switch statement or two branches in an if chain with the same implementation is at <br /> best duplicate code, and at worst a coding error. If the same logic is truly needed for both instances, then in an if chain they should <br /> be combined, or for a switch, one should fall through to the other. <br /> Noncompliant Code Example <br />  <br /> switch (i) { <br />   case 1: <br />     doFirstThing(); <br />     doSomething(); <br />     break; <br />   case 2: <br />     doSomethingDifferent(); <br />     break; <br />   case 3:  // Noncompliant; duplicates case 1's implementation <br />     doFirstThing(); <br />     doSomething(); <br />     break; <br />   default: <br />     doTheRest(); <br /> } <br />  <br /> if (a &gt;= 0 &amp;&amp; a &lt; 10) { <br />   doFirstThing(); <br />   doTheThing(); <br /> } <br /> else if (a &gt;= 10 &amp;&amp; a &lt; 20) { <br />   doTheOtherThing(); <br /> } <br /> else if (a &gt;= 20 &amp;&amp; a &lt; 50) { <br />   doFirstThing(); <br />   doTheThing();  // Noncompliant; duplicates first condition <br /> } <br /> else { <br />   doTheRest(); <br /> } <br />  <br /> Exceptions <br /> Blocks in an if chain that contain a single line of code are ignored, as are blocks in a switch statement that contain a <br /> single line of code with or without a following break. <br />  <br /> if (a == 1) { <br />   doSomething();  //no issue, usually this is done on purpose to increase the readability <br /> } else if (a == 2) { <br />   doSomethingElse(); <br /> } else { <br />   doSomething(); <br /> } <br />  <br /> But this exception does not apply to if chains without else-s, or to switch-es without default clauses when <br /> all branches have the same single line of code. In case of if chains with else-s, or of switch-es with default <br /> clauses, rule S3923 raises a bug. <br />  <br /> if (a == 1) { <br />   doSomething();  //Noncompliant, this might have been done on purpose but probably not <br /> } else if (a == 2) { <br />   doSomething(); <br /> } <br /> |CODE_SMELL|MAJOR|3
"static" members should be accessed statically|While it is possible to access static members from a class instance, itâ€™s bad form, and considered by most to be misleading <br /> because it implies to the readers of your code that thereâ€™s an instance of the member per class instance. <br /> Noncompliant Code Example <br />  <br /> public class A { <br />   public static int counter = 0; <br /> } <br />  <br /> public class B { <br />   private A first = new A(); <br />   private A second = new A(); <br />  <br />   public void runUpTheCount() { <br />     first.counter ++;  // Noncompliant <br />     second.counter ++;  // Noncompliant. A.counter is now 2, which is perhaps contrary to expectations <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class A { <br />   public static int counter = 0; <br /> } <br />  <br /> public class B { <br />   private A first = new A(); <br />   private A second = new A(); <br />  <br />   public void runUpTheCount() { <br />     A.counter ++;  // Compliant <br />     A.counter ++;  // Compliant <br />   } <br /> } <br /> |CODE_SMELL|MAJOR|1
Classes with only "static" methods should not be instantiated|static methods can be accessed without an instance of the enclosing class, so thereâ€™s no reason to instantiate a class that has only <br /> static methods. <br /> Noncompliant Code Example <br />  <br /> public class TextUtils { <br />   public static String stripHtml(String source) { <br />     return source.replaceAll("&lt;[^&gt;]+&gt;", ""); <br />   } <br /> } <br />  <br /> public class TextManipulator { <br />  <br />   // ... <br />  <br />   public void cleanText(String source) { <br />     TextUtils textUtils = new TextUtils(); // Noncompliant <br />  <br />     String stripped = textUtils.stripHtml(source); <br />  <br />     //... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class TextUtils { <br />   public static String stripHtml(String source) { <br />     return source.replaceAll("&lt;[^&gt;]+&gt;", ""); <br />   } <br /> } <br />  <br /> public class TextManipulator { <br />  <br />   // ... <br />  <br />   public void cleanText(String source) { <br />     String stripped = TextUtils.stripHtml(source); <br />  <br />     //... <br />   } <br /> } <br />  <br /> See Also <br />  <br />    S1118 - Utility classes should not have public constructors  <br /> |CODE_SMELL|MAJOR|1
Boolean expressions should not be gratuitous|If a boolean expression doesnâ€™t change the evaluation of the condition, then it is entirely unnecessary, and can be removed. If it is gratuitous <br /> because it does not match the programmerâ€™s intent, then itâ€™s a bug and the expression should be fixed. <br /> Noncompliant Code Example <br />  <br /> a = true; <br /> if (a) { // Noncompliant <br />   doSomething(); <br /> } <br />  <br /> if (b &amp;&amp; a) { // Noncompliant; "a" is always "true" <br />   doSomething(); <br /> } <br />  <br /> if (c &#124&#124 !a) { // Noncompliant; "!a" is always "false" <br />   doSomething(); <br /> } <br />  <br /> Compliant Solution <br />  <br /> a = true; <br /> if (foo(a)) { <br />   doSomething(); <br /> } <br />  <br /> if (b) { <br />   doSomething(); <br /> } <br />  <br /> if (c) { <br />   doSomething(); <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-571 - Expression is Always True  <br />    MITRE, CWE-570 - Expression is Always False  <br /> |CODE_SMELL|MAJOR|1
"Preconditions" and logging arguments should not require evaluation|Passing message arguments that require further evaluation into a Guava com.google.common.base.Preconditions check can result in a <br /> performance penalty. Thatâ€™s because whether or not theyâ€™re needed, each argument must be resolved before the method is actually called. <br /> Similarly, passing concatenated strings into a logging method can also incur a needless performance hit because the concatenation will be performed <br /> every time the method is called, whether or not the log level is low enough to show the message. <br /> Instead, you should structure your code to pass static or pre-computed values into Preconditions conditions check and logging <br /> calls. <br /> Specifically, the built-in string formatting should be used instead of string concatenation, and if the message is the result of a method call, <br /> then Preconditions should be skipped altogether, and the relevant exception should be conditionally thrown instead. <br /> Noncompliant Code Example <br />  <br /> logger.log(Level.DEBUG, "Something went wrong: " + message);  // Noncompliant; string concatenation performed even when log level too high to show DEBUG messages <br />  <br /> logger.fine("An exception occurred with message: " + message); // Noncompliant <br />  <br /> LOG.error("Unable to open file " + csvPath, e);  // Noncompliant <br />  <br /> Preconditions.checkState(a &gt; 0, "Arg must be positive, but got " + a);  // Noncompliant. String concatenation performed even when a &gt; 0 <br />  <br /> Preconditions.checkState(condition, formatMessage());  // Noncompliant. formatMessage() invoked regardless of condition <br />  <br /> Preconditions.checkState(condition, "message: %s", formatMessage());  // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> logger.log(Level.SEVERE, "Something went wrong: {0} ", message);  // String formatting only applied if needed <br />  <br /> logger.fine("An exception occurred with message: {}", message);  // SLF4J, Log4j <br />  <br /> logger.log(Level.SEVERE, () -&gt; "Something went wrong: " + message); // since Java 8, we can use Supplier , which will be evaluated lazily <br />  <br /> LOG.error("Unable to open file {0}", csvPath, e); <br />  <br /> if (LOG.isDebugEnabled()) { <br />   LOG.debug("Unable to open file " + csvPath, e);  // this is compliant, because it will not evaluate if log level is above debug. <br /> } <br />  <br /> Preconditions.checkState(arg &gt; 0, "Arg must be positive, but got %d", a);  // String formatting only applied if needed <br />  <br /> if (!condition) { <br />   throw new IllegalStateException(formatMessage());  // formatMessage() only invoked conditionally <br /> } <br />  <br /> if (!condition) { <br />   throw new IllegalStateException("message: " + formatMessage()); <br /> } <br />  <br /> Exceptions <br /> catch blocks are ignored, because the performance penalty is unimportant on exceptional paths (catch block should not be a part of <br /> standard program flow). Getters are ignored as well as methods called on annotations which can be considered as getters. This rule accounts for <br /> explicit test-level testing with SLF4J methods isXXXEnabled and ignores the bodies of such if statements.|CODE_SMELL|MAJOR|35
Static fields should not be updated in constructors|Assigning a value to a static field in a constructor could cause unreliable behavior at runtime since it will change the value for all <br /> instances of the class. <br /> Instead remove the fieldâ€™s static modifier, or initialize it statically. <br /> Noncompliant Code Example <br />  <br /> public class Person { <br />   static Date dateOfBirth; <br />   static int expectedFingers; <br />  <br />   public Person(date birthday) { <br />     dateOfBirth = birthday;  // Noncompliant; now everyone has this birthday <br />     expectedFingers = 10;  // Noncompliant <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Person { <br />   Date dateOfBirth; <br />   static int expectedFingers = 10; <br />  <br />   public Person(date birthday) { <br />     dateOfBirth = birthday; <br />   } <br /> } <br /> |CODE_SMELL|MAJOR|1
Reflection should not be used to increase accessibility of classes, methods, or fields|This rule raises an issue when reflection is used to change the visibility of a class, method or field, and when it is used to directly update a <br /> field value. Altering or bypassing the accessibility of classes, methods, or fields violates the encapsulation principle and could lead to run-time <br /> errors. <br /> Noncompliant Code Example <br />  <br /> public void makeItPublic(String methodName) throws NoSuchMethodException { <br />  <br />   this.getClass().getMethod(methodName).setAccessible(true); // Noncompliant <br /> } <br />  <br /> public void setItAnyway(String fieldName, int value) { <br />   this.getClass().getDeclaredField(fieldName).setInt(this, value); // Noncompliant; bypasses controls in setter <br /> } <br />  <br /> See <br />  <br />    CERT, SEC05-J. - Do not use reflection to increase accessibility of classes, <br />   methods, or fields  <br /> |CODE_SMELL|MAJOR|6
Printf-style format strings should be used correctly|Because printf-style format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that <br /> result in the wrong strings being created. This rule statically validates the correlation of printf-style format strings to their <br /> arguments when calling the format(...) methods of java.util.Formatter, java.lang.String, <br /> java.io.PrintStream, MessageFormat, and java.io.PrintWriter classes and the printf(...) methods of <br /> java.io.PrintStream or java.io.PrintWriter classes. <br /> Noncompliant Code Example <br />  <br /> String.format("First {0} and then {1}", "foo", "bar");  //Noncompliant. Looks like there is a confusion with the use of {{java.text.MessageFormat}}, parameters "foo" and "bar" will be simply ignored here <br /> String.format("Display %3$d and then %d", 1, 2, 3);   //Noncompliant; the second argument '2' is unused <br /> String.format("Too many arguments %d and %d", 1, 2, 3);  //Noncompliant; the third argument '3' is unused <br /> String.format("First Line\n");   //Noncompliant; %n should be used in place of \n to produce the platform-specific line separator <br /> String.format("Is myObject null ? %b", myObject);   //Noncompliant; when a non-boolean argument is formatted with %b, it prints true for any nonnull value, and false for null. Even if intended, this is misleading. It's better to directly inject the boolean value (myObject == null in this case) <br /> String.format("value is " + value); // Noncompliant <br /> String s = String.format("string without arguments"); // Noncompliant <br />  <br /> MessageFormat.format("Result '{0}'.", value); // Noncompliant; String contains no format specifiers. (quote are discarding format specifiers) <br /> MessageFormat.format("Result {0}.", value, value);  // Noncompliant; 2nd argument is not used <br /> MessageFormat.format("Result {0}.", myObject.toString()); // Noncompliant; no need to call toString() on objects <br />  <br /> java.util.Logger logger; <br /> logger.log(java.util.logging.Level.SEVERE, "Result {0}.", myObject.toString()); // Noncompliant; no need to call toString() on objects <br /> logger.log(java.util.logging.Level.SEVERE, "Result.", new Exception()); // compliant, parameter is an exception <br /> logger.log(java.util.logging.Level.SEVERE, "Result '{0}'", 14); // Noncompliant - String contains no format specifiers. <br /> logger.log(java.util.logging.Level.SEVERE, "Result " + param, exception); // Noncompliant; Lambda should be used to differ string concatenation. <br />  <br /> org.slf4j.Logger slf4jLog; <br /> org.slf4j.Marker marker; <br />  <br /> slf4jLog.debug(marker, "message {}"); <br /> slf4jLog.debug(marker, "message", 1); // Noncompliant - String contains no format specifiers. <br />  <br /> org.apache.logging.log4j.Logger log4jLog; <br /> log4jLog.debug("message", 1); // Noncompliant - String contains no format specifiers. <br />  <br /> Compliant Solution <br />  <br /> String.format("First %s and then %s", "foo", "bar"); <br /> String.format("Display %2$d and then %d", 1, 3); <br /> String.format("Too many arguments %d %d", 1, 2); <br /> String.format("First Line%n"); <br /> String.format("Is myObject null ? %b", myObject == null); <br /> String.format("value is %d", value); <br /> String s = "string without arguments"; <br />  <br /> MessageFormat.format("Result {0}.", value); <br /> MessageFormat.format("Result '{0}'  =  {0}", value); <br /> MessageFormat.format("Result {0}.", myObject); <br />  <br /> java.util.Logger logger; <br /> logger.log(java.util.logging.Level.SEVERE, "Result {0}.", myObject); <br /> logger.log(java.util.logging.Level.SEVERE, "Result {0}'", 14); <br /> logger.log(java.util.logging.Level.SEVERE, exception, () -&gt; "Result " + param); <br />  <br /> org.slf4j.Logger slf4jLog; <br /> org.slf4j.Marker marker; <br />  <br /> slf4jLog.debug(marker, "message {}"); <br /> slf4jLog.debug(marker, "message {}", 1); <br />  <br /> org.apache.logging.log4j.Logger log4jLog; <br /> log4jLog.debug("message {}", 1); <br />  <br /> See <br />  <br />    CERT, FIO47-C. - Use valid format strings  <br /> |CODE_SMELL|MAJOR|42
Raw types should not be used|Generic types shouldnâ€™t be used raw (without type parameters) in variable declarations or return values. Doing so bypasses generic type checking, <br /> and defers the catch of unsafe code to runtime. <br /> Noncompliant Code Example <br />  <br /> List myList; // Noncompliant <br /> Set mySet; // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> List&lt;String&gt; myList; <br /> Set&lt;? extends Number&gt; mySet; <br /> |CODE_SMELL|MAJOR|7
"java.nio.Files#delete" should be preferred|When java.io.File#delete fails, this boolean method simply returns false with no indication of the cause. On <br /> the other hand, when java.nio.file.Files#delete fails, this void method returns one of a series of exception types to better <br /> indicate the cause of the failure. And since more information is generally better in a debugging situation, java.nio.file.Files#delete is <br /> the preferred option. <br /> Noncompliant Code Example <br />  <br /> public void cleanUp(Path path) { <br />   File file = new File(path); <br />   if (!file.delete()) {  // Noncompliant <br />     //... <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void cleanUp(Path path) throws NoSuchFileException, DirectoryNotEmptyException, IOException { <br />   Files.delete(path); <br /> } <br /> |CODE_SMELL|MAJOR|1
"Class.forName()" should not load JDBC 4.0+ drivers|In the past, it was required to load a JDBC driver before creating a java.sql.Connection. Nowadays, when using JDBC 4.0 drivers, this <br /> is no longer required and Class.forName() can be safely removed because JDBC 4.0 (JDK 6) drivers available in the classpath are <br /> automatically loaded. <br /> This rule raises an issue when Class.forName() is used with one of the following values: <br />  <br />    com.mysql.jdbc.Driver  <br />    oracle.jdbc.driver.OracleDriver  <br />    com.ibm.db2.jdbc.app.DB2Driver  <br />    com.ibm.db2.jdbc.net.DB2Driver  <br />    com.sybase.jdbc.SybDriver  <br />    com.sybase.jdbc2.jdbc.SybDriver  <br />    com.teradata.jdbc.TeraDriver  <br />    com.microsoft.sqlserver.jdbc.SQLServerDriver  <br />    org.postgresql.Driver  <br />    sun.jdbc.odbc.JdbcOdbcDriver  <br />    org.hsqldb.jdbc.JDBCDriver  <br />    org.h2.Driver  <br />    org.firebirdsql.jdbc.FBDriver  <br />    net.sourceforge.jtds.jdbc.Driver  <br />    com.ibm.db2.jcc.DB2Driver  <br />  <br /> Noncompliant Code Example <br />  <br /> import java.sql.Connection; <br /> import java.sql.DriverManager; <br /> import java.sql.SQLException; <br />  <br /> public class Demo { <br />   private static final String DRIVER_CLASS_NAME = "org.postgresql.Driver"; <br />   private final Connection connection; <br />  <br />   public Demo(String serverURI) throws SQLException, ClassNotFoundException { <br />     Class.forName(DRIVER_CLASS_NAME); // Noncompliant; no longer required to load the JDBC Driver using Class.forName() <br />     connection = DriverManager.getConnection(serverURI); <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> import java.sql.Connection; <br /> import java.sql.DriverManager; <br /> import java.sql.SQLException; <br />  <br /> public class Demo { <br />     private final Connection connection; <br />  <br />     public Demo(String serverURI) throws SQLException { <br />         connection = DriverManager.getConnection(serverURI); <br />     } <br /> } <br /> |CODE_SMELL|MAJOR|1
Method names should comply with a naming convention|Shared naming conventions allow teams to collaborate efficiently. This rule checks that all method names match a provided regular expression. <br /> Noncompliant Code Example <br /> With default provided regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> public int DoSomething(){...} <br />  <br /> Compliant Solution <br />  <br /> public int doSomething(){...} <br />  <br /> Exceptions <br /> Overriding methods are excluded. <br />  <br /> @Override <br /> public int Do_Something(){...} <br /> |CODE_SMELL|MINOR|48
Class names should comply with a naming convention|Shared coding conventions allow teams to collaborate effectively. This rule allows to check that all class names match a provided regular <br /> expression. <br /> Noncompliant Code Example <br /> With default provided regular expression ^[A-Z][a-zA-Z0-9]*$: <br />  <br /> class my_class {...} <br />  <br /> Compliant Solution <br />  <br /> class MyClass {...} <br /> |CODE_SMELL|MINOR|3
Class variable fields should not have public accessibility|Public class variable fields do not respect the encapsulation principle and has three main disadvantages: <br />  <br />    Additional behavior such as validation cannot be added.  <br />    The internal representation is exposed, and cannot be changed afterwards.  <br />    Member values are subject to change from anywhere in the code and may not meet the programmerâ€™s assumptions.  <br />  <br /> By using private attributes and accessor methods (set and get), unauthorized modifications are prevented. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { <br />  <br />   public static final int SOME_CONSTANT = 0;     // Compliant - constants are not checked <br />  <br />   public String firstName;                       // Noncompliant <br />  <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class MyClass { <br />  <br />   public static final int SOME_CONSTANT = 0;     // Compliant - constants are not checked <br />  <br />   private String firstName;                      // Compliant <br />  <br />   public String getFirstName() { <br />     return firstName; <br />   } <br />  <br />   public void setFirstName(String firstName) { <br />     this.firstName = firstName; <br />   } <br />  <br /> } <br />  <br /> Exceptions <br /> Because they are not modifiable, this rule ignores public final fields. Also, annotated fields, whatever the annotation(s) will be <br /> ignored, as annotations are often used by injection frameworks, which in exchange require having public fields. <br /> See <br />  <br />    MITRE, CWE-493 - Critical Public Variable Without Final Modifier  <br /> |CODE_SMELL|MINOR|3
Modifiers should be declared in the correct order|The Java Language Specification recommends listing modifiers in the following order: <br />  <br />    Annotations  <br />    public  <br />    protected  <br />    private  <br />    abstract  <br />    static  <br />    final  <br />    transient  <br />    volatile  <br />    synchronized  <br />    native  <br />    default  <br />    strictfp  <br />  <br /> Not following this convention has no technical impact, but will reduce the codeâ€™s readability because most developers are used to the standard <br /> order. <br /> Noncompliant Code Example <br />  <br /> static public void main(String[] args) {   // Noncompliant <br /> } <br />  <br /> Compliant Solution <br />  <br /> public static void main(String[] args) {   // Compliant <br /> } <br /> |CODE_SMELL|MINOR|1
Unnecessary imports should be removed|The imports part of a file should be handled by the Integrated Development Environment (IDE), not manually by the developer. <br /> Unused and useless imports should not occur if that is the case. <br /> Leaving them in reduces the codeâ€™s readability, since their presence can be confusing. <br /> Noncompliant Code Example <br />  <br /> package my.company; <br />  <br /> import java.lang.String;        // Noncompliant; java.lang classes are always implicitly imported <br /> import my.company.SomeClass;    // Noncompliant; same-package files are always implicitly imported <br /> import java.io.File;            // Noncompliant; File is not used <br />  <br /> import my.company2.SomeType; <br /> import my.company2.SomeType;    // Noncompliant; 'SomeType' is already imported <br />  <br /> class ExampleClass { <br />  <br />   public String someString; <br />   public SomeType something; <br />  <br /> } <br />  <br /> Exceptions <br /> Imports for types mentioned in Javadocs are ignored.|CODE_SMELL|MINOR|7
"throws" declarations should not be superfluous|An exception in a throws declaration in Java is superfluous if it is: <br />  <br />    listed multiple times  <br />    a subclass of another listed exception  <br />    completely unnecessary because the declared exception type cannot actually be thrown  <br />  <br /> Noncompliant Code Example <br />  <br /> void foo() throws MyException, MyException {}  // Noncompliant; should be listed once <br /> void bar() throws Throwable, Exception {}  // Noncompliant; Exception is a subclass of Throwable <br />  <br /> Compliant Solution <br />  <br /> void foo() throws MyException {} <br /> void bar() throws Throwable {} <br />  <br /> Exceptions <br /> The rule will not raise any issue for exceptions that cannot be thrown from the method body: <br />  <br />    in overriding and implementation methods  <br />    in interface default methods  <br />    in non-private methods that only throw, have empty bodies, or a single return statement.  <br />    in overridable methods (non-final, or not member of a final class, non-static, non-private), if the exception is documented with a proper <br />   JavaDoc  <br />  <br /> Also, the rule wonâ€™t raise issues on RuntimeException, or one of its descendants, because explicating runtime exceptions which could <br /> be thrown can ultimately help the methodâ€™s users, and can even be considered as good practice. <br />  <br /> class A extends B { <br />   @Override <br />   void doSomething() throws IOException { <br />     compute(a); <br />   } <br />  <br />   public void foo() throws IOException {} <br />  <br />   public void qix() throws MyRuntimeException {} <br />  <br />   protected void bar() throws IOException { <br />     throw new UnsupportedOperationException("This method should be implemented in subclasses"); <br />   } <br />  <br />   Object foobar(String s) throws IOException { <br />     return null; <br />   } <br />  <br />   /** <br />    * @throws IOException Overriding classes may throw this exception if they print values into a file <br />    */ <br />   protected void print() throws IOException { // no issue, method is overridable and the exception has proper javadoc <br />     System.out.println("foo"); <br />   } <br /> } <br /> |CODE_SMELL|MINOR|1
Local variable and method parameter names should comply with a naming convention|Shared naming conventions allow teams to collaborate effectively. This rule raises an issue when a local variable or function parameter name does <br /> not match the provided regular expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> public void doSomething(int my_param) { <br />   int LOCAL; <br />   ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> public void doSomething(int myParam) { <br />   int local; <br />   ... <br /> } <br />  <br /> Exceptions <br /> Loop counters are ignored by this rule. <br />  <br /> for (int i_1 = 0; i_1 &lt; limit; i_1++) {  // Compliant <br />   // ... <br /> } <br />  <br /> as well as one-character catch variables: <br />  <br /> try { <br /> //... <br /> } catch (Exception e) { // Compliant <br /> } <br /> |CODE_SMELL|MINOR|14
Overriding methods should do more than simply call the same method in the super class|Overriding a method just to call the same method from the super class without performing any other actions is useless and misleading. The only time <br /> this is justified is in final overriding methods, where the effect is to lock in the parent class behavior. This rule ignores such <br /> overrides of equals, hashCode and toString. <br /> Noncompliant Code Example <br />  <br /> public void doSomething() { <br />   super.doSomething(); <br /> } <br />  <br /> @Override <br /> public boolean isLegal(Action action) { <br />   return super.isLegal(action); <br /> } <br />  <br /> Compliant Solution <br />  <br /> @Override <br /> public boolean isLegal(Action action) {         // Compliant - not simply forwarding the call <br />   return super.isLegal(new Action(/* ... */)); <br /> } <br />  <br /> @Id <br /> @Override <br /> public int getId() {                            // Compliant - there is annotation different from @Override <br />   return super.getId(); <br /> } <br /> |CODE_SMELL|MINOR|2
Array designators "[]" should be on the type, not the variable|Array designators should always be located on the type for better code readability. Otherwise, developers must look both at the type and the <br /> variable name to know whether or not a variable is an array. <br /> Noncompliant Code Example <br />  <br /> int matrix[][];   // Noncompliant <br /> int[] matrix[];   // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> int[][] matrix;   // Compliant <br /> |CODE_SMELL|MINOR|6
Package names should comply with a naming convention|Shared coding conventions allow teams to collaborate efficiently. This rule checks that all package names match a provided regular expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[a-z_]+(\.[a-z_][a-z0-9_]*)*$: <br />  <br /> package org.exAmple; // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> package org.example; <br /> |CODE_SMELL|MINOR|3
The default unnamed package should not be used|According to the Java Language Specification: <br />  <br />   Unnamed packages are provided by the Java platform principally for convenience when developing small or temporary applications or when just <br />   beginning development. <br />  <br /> To enforce this best practice, classes located in default package can no longer be accessed from named ones since Java 1.4. <br /> Noncompliant Code Example <br />  <br /> public class MyClass { /* ... */ } <br />  <br /> Compliant Solution <br />  <br /> package org.example; <br />  <br /> public class MyClass{ /* ... */ } <br /> |CODE_SMELL|MINOR|1
Declarations should use Java collection interfaces such as "List" rather than specific implementation classes such as "LinkedList"|The purpose of the Java Collections API is to provide a well defined hierarchy of interfaces in order to hide implementation details. <br /> Implementing classes must be used to instantiate new collections, but the result of an instantiation should ideally be stored in a variable whose <br /> type is a Java Collection interface. <br /> This rule raises an issue when an implementation class: <br />  <br />    is returned from a public method.  <br />    is accepted as an argument to a public method.  <br />    is exposed as a public member.  <br />  <br /> Noncompliant Code Example <br />  <br /> public class Employees { <br />   private HashSet&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;();  // Noncompliant - "employees" should have type "Set" rather than "HashSet" <br />  <br />   public HashSet&lt;Employee&gt; getEmployees() {                       // Noncompliant <br />     return employees; <br />   } <br /> } <br />  <br /> Compliant Solution <br />  <br /> public class Employees { <br />   private Set&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;();      // Compliant <br />  <br />   public Set&lt;Employee&gt; getEmployees() {                           // Compliant <br />     return employees; <br />   } <br /> } <br /> |CODE_SMELL|MINOR|5
Loops should not contain more than a single "break" or "continue" statement|Restricting the number of break and continue statements in a loop is done in the interest of good structured <br /> programming. <br /> Only one break or one continue statement is acceptable in a loop, since it facilitates optimal coding. If there is more <br /> than one, the code should be refactored to increase readability. <br /> Noncompliant Code Example <br />  <br /> for (int i = 1; i &lt;= 10; i++) {     // Noncompliant - 2 continue - one might be tempted to add some logic in between <br />   if (i % 2 == 0) { <br />     continue; <br />   } <br />  <br />   if (i % 3 == 0) { <br />     continue; <br />   } <br />  <br />   System.out.println("i = " + i); <br /> } <br /> |CODE_SMELL|MINOR|1
Unused local variables should be removed|If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will <br /> not wonder what the variable is used for. <br /> Noncompliant Code Example <br />  <br /> public int numberOfMinutes(int hours) { <br />   int seconds = 0;   // seconds is never used <br />   return hours * 60; <br /> } <br />  <br /> Compliant Solution <br />  <br /> public int numberOfMinutes(int hours) { <br />   return hours * 60; <br /> } <br /> |CODE_SMELL|MINOR|2
"@Deprecated" code should not be used|Once deprecated, classes, and interfaces, and their members should be avoided, rather than used, inherited or extended. Deprecation is a warning <br /> that the class or interface has been superseded, and will eventually be removed. The deprecation period allows you to make a smooth transition away <br /> from the aging, soon-to-be-retired technology. <br /> Noncompliant Code Example <br />  <br /> /** <br />  * @deprecated  As of release 1.3, replaced by {@link #Fee} <br />  */ <br /> @Deprecated <br /> public class Fum { ... } <br />  <br /> public class Foo { <br />   /** <br />    * @deprecated  As of release 1.7, replaced by {@link #doTheThingBetter()} <br />    */ <br />   @Deprecated <br />   public void doTheThing() { ... } <br />  <br />   public void doTheThingBetter() { ... } <br /> } <br />  <br /> public class Bar extends Foo { <br />   public void doTheThing() { ... } // Noncompliant; don't override a deprecated method or explicitly mark it as @Deprecated <br /> } <br />  <br /> public class Bar extends Fum {  // Noncompliant; Fum is deprecated <br />  <br />   public void myMethod() { <br />     Foo foo = new Foo();  // okay; the class isn't deprecated <br />     foo.doTheThing();  // Noncompliant; doTheThing method is deprecated <br />   } <br /> } <br />  <br /> See <br />  <br />    MITRE, CWE-477 - Use of Obsolete Functions  <br />    CERT, MET02-J. - Do not use deprecated or obsolete classes or methods  <br /> |CODE_SMELL|MINOR|5
The diamond operator ("<>") should be used|Java 7 introduced the diamond operator (&lt;&gt;) to reduce the verbosity of generics code. For instance, instead of having to declare <br /> a List's type in both its declaration and its constructor, you can now simplify the constructor declaration with &lt;&gt;, <br /> and the compiler will infer the type. <br /> Note that this rule is automatically disabled when the projectâ€™s sonar.java.source is lower than 7. <br /> Noncompliant Code Example <br />  <br /> List&lt;String&gt; strings = new ArrayList&lt;String&gt;();  // Noncompliant <br /> Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;String,List&lt;Integer&gt;&gt;();  // Noncompliant <br />  <br /> Compliant Solution <br />  <br /> List&lt;String&gt; strings = new ArrayList&lt;&gt;(); <br /> Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); <br /> |CODE_SMELL|MINOR|1
Static non-final field names should comply with a naming convention|Shared naming conventions allow teams to collaborate efficiently. This rule checks that static non-final field names match a provided regular <br /> expression. <br /> Noncompliant Code Example <br /> With the default regular expression ^[a-z][a-zA-Z0-9]*$: <br />  <br /> public final class MyClass { <br />    private static String foo_bar; <br /> } <br />  <br /> Compliant Solution <br />  <br /> class MyClass { <br />    private static String fooBar; <br /> } <br /> |CODE_SMELL|MINOR|1
Composed "@RequestMapping" variants should be preferred|Spring framework 4.3 introduced variants of the @RequestMapping annotation to better represent the semantics of the annotated methods. <br /> The use of @GetMapping, @PostMapping, @PutMapping, @PatchMapping and @DeleteMapping <br /> should be preferred to the use of the raw @RequestMapping(method = RequestMethod.XYZ). <br /> Noncompliant Code Example <br />  <br /> @RequestMapping(path = "/greeting", method = RequestMethod.GET) // Noncompliant <br /> public Greeting greeting(@RequestParam(value = "name", defaultValue = "World") String name) { <br /> ... <br /> } <br />  <br /> Compliant Solution <br />  <br /> @GetMapping(path = "/greeting") // Compliant <br /> public Greeting greeting(@RequestParam(value = "name", defaultValue = "World") String name) { <br /> ... <br /> } <br /> |CODE_SMELL|MINOR|14
Avoid using boxed "Boolean" types directly in boolean expressions|When boxed type java.lang.Boolean is used as an expression to determine the control flow (as described in Java Language Specification Â§4.2.5 The boolean Type and <br /> boolean Values) it will throw a NullPointerException if the value is null (as defined in Java Language Specification Â§5.1.8 Unboxing Conversion). <br /> It is safer to avoid such conversion altogether and handle the null value explicitly. <br /> Note, however, that no issues will be raised for Booleans that have already been null-checked. <br /> Noncompliant Code Example <br />  <br /> Boolean b = getBoolean(); <br /> if (b) {  // Noncompliant, it will throw NPE when b == null <br />   foo(); <br /> } else { <br />   bar(); <br /> } <br />  <br /> Compliant Solution <br />  <br /> Boolean b = getBoolean(); <br /> if (Boolean.TRUE.equals(b)) { <br />   foo(); <br /> } else { <br />   bar();  // will be invoked for both b == false and b == null <br /> } <br />  <br />  <br /> Boolean b = getBoolean(); <br /> if(b != null){ <br />   String test = b ? "test" : ""; <br /> } <br />  <br /> See <br />  <br />    Java Language Specification Â§5.1.8 Unboxing Conversion <br />    <br /> |CODE_SMELL|MINOR|6
XML parsers should not be vulnerable to XXE attacks|XML standard allows the use of entities, declared in the DOCTYPE of the document, which can be internal or external. <br /> When parsing the XML file, the content of the external entities is retrieved from an external storage such as the file system or network, which may <br /> lead, if no restrictions are put in place, to arbitrary file disclosures or server-side request forgery (SSRF) vulnerabilities. <br /> Itâ€™s recommended to limit resolution of external entities by using one of these solutions: <br />  <br />    If DOCTYPE is not necessary, completely disable all DOCTYPE declarations.  <br />    If external entities are not necessary, completely disable their declarations.  <br />    If external entities are necessary then: <br />      <br />        Use XML processor features, if available, to authorize only required protocols (eg: https).  <br />        And use an entity resolver (and optionally an XML Catalog) to resolve only trusted entities. == Noncompliant Code Example  <br />        <br />  <br /> For DocumentBuilder, SAXParser, XMLInput, Transformer and Schema JAPX factories: <br />  <br /> DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // Noncompliant <br />  <br /> SAXParserFactory factory = SAXParserFactory.newInstance(); // Noncompliant <br />  <br /> XMLInputFactory factory = XMLInputFactory.newInstance(); // Noncompliant <br />  <br /> TransformerFactory factory = javax.xml.transform.TransformerFactory.newInstance();  // Noncompliant <br />  <br /> SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);  // Noncompliant <br />  <br /> For Dom4j library: <br />  <br /> SAXReader xmlReader = new SAXReader(); // Noncompliant <br />  <br /> For Jdom2 library: <br />  <br /> SAXBuilder builder = new SAXBuilder(); // Noncompliant <br />  <br /> Compliant Solution <br /> For DocumentBuilder, SAXParser, XMLInput, Transformer and Schema JAPX factories: <br />  <br /> DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); <br /> // to be compliant, completely disable DOCTYPE declaration: <br /> factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true); <br /> // or completely disable external entities declarations: <br /> factory.setFeature("http://xml.org/sax/features/external-general-entities", false); <br /> factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false); <br /> // or prohibit the use of all protocols by external entities: <br /> factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, ""); <br /> factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, ""); <br /> // or disable entity expansion but keep in mind that this doesn't prevent fetching external entities <br /> // and this solution is not correct for OpenJDK &lt; 13 due to a bug: https://bugs.openjdk.java.net/browse/JDK-8206132 <br /> factory.setExpandEntityReferences(false); <br />  <br />  <br /> SAXParserFactory factory = SAXParserFactory.newInstance(); <br /> // to be compliant, completely disable DOCTYPE declaration: <br /> factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true); <br /> // or completely disable external entities declarations: <br /> factory.setFeature("http://xml.org/sax/features/external-general-entities", false); <br /> factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false); <br /> // or prohibit the use of all protocols by external entities: <br /> SAXParser parser = factory.newSAXParser(); // Noncompliant <br /> parser.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, ""); <br /> parser.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, ""); <br />  <br /> XMLInputFactory factory = XMLInputFactory.newInstance(); <br /> // to be compliant, completely disable DOCTYPE declaration: <br /> factory.setProperty(XMLInputFactory.SUPPORT_DTD, false); <br /> // or completely disable external entities declarations: <br /> factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE); <br /> // or prohibit the use of all protocols by external entities: <br /> factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, ""); <br /> factory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, ""); <br />  <br /> TransformerFactory factory = javax.xml.transform.TransformerFactory.newInstance(); <br /> // to be compliant, prohibit the use of all protocols by external entities: <br /> factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, ""); <br /> factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, ""); <br />  <br /> SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI); <br /> // to be compliant, completely disable DOCTYPE declaration: <br /> factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true); <br /> // or prohibit the use of all protocols by external entities: <br /> factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, ""); <br /> factory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, ""); <br />  <br /> For Dom4j library: <br />  <br /> SAXReader xmlReader = new SAXReader(); <br /> xmlReader.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true); <br />  <br /> For Jdom2 library: <br />  <br /> SAXBuilder builder = new SAXBuilder(); <br /> builder.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, ""); <br /> builder.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, ""); <br />  <br /> See <br />  <br />    OWASP Top 10 2021 Category A5 - Security Misconfiguration  <br />    Oracle Java Documentation - XML External Entity Injection Attack  <br />    OWASP Top 10 2017 Category A4 - XML External <br />   Entities (XXE)  <br />    OWASP XXE Prevention Cheat <br />   Sheet  <br />    MITRE, CWE-611 - Information Exposure Through XML External Entity Reference  <br />    MITRE, CWE-827 - Improper Control of Document Type Definition  <br /> |VULNERABILITY|BLOCKER|9
XML parsers should not allow inclusion of arbitrary files|XML standard allows the inclusion of xml files with the xinclude element. <br /> XML processors will replace an xinclude element with the content of the file located at the URI defined in the href attribute, potentially from an <br /> external storage such as file system or network, which may lead, if no restrictions are put in place, to arbitrary file disclosures or server-side request forgery (SSRF) vulnerabilities. <br /> Noncompliant Code Example <br /> For DocumentBuilder, SAXParser, XMLInput, Transformer and Schema JAPX factories: <br />  <br /> factory.setXIncludeAware(true); // Noncompliant <br /> // or <br /> factory.setFeature("http://apache.org/xml/features/xinclude", true); // Noncompliant <br />  <br /> For Dom4j library: <br />  <br /> SAXReader xmlReader = new SAXReader(); <br /> xmlReader.setFeature("http://apache.org/xml/features/xinclude", true); // Noncompliant <br />  <br /> For Jdom2 library: <br />  <br /> SAXBuilder builder = new SAXBuilder(); <br /> builder.setFeature("http://apache.org/xml/features/xinclude", true); // Noncompliant <br />  <br /> Compliant Solution <br /> Xinclude is disabled by default and can be explicitely disabled like below. <br /> For DocumentBuilder, SAXParser, XMLInput, Transformer and Schema JAPX factories: <br />  <br /> factory.setXIncludeAware(false); <br /> // or <br /> factory.setFeature("http://apache.org/xml/features/xinclude", false); <br />  <br /> For Dom4j library: <br />  <br /> SAXReader xmlReader = new SAXReader(); <br /> xmlReader.setFeature("http://apache.org/xml/features/xinclude", false); <br />  <br /> For Jdom2 library: <br />  <br /> SAXBuilder builder = new SAXBuilder(); <br /> builder.setFeature("http://apache.org/xml/features/xinclude", false); <br />  <br /> Exceptions <br /> This rule does not raise issues when Xinclude is enabled with a custom EntityResolver: <br /> For DocumentBuilderFactory: <br />  <br /> DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); <br /> factory.setXIncludeAware(true); <br /> // ... <br /> DocumentBuilder builder = factory.newDocumentBuilder(); <br /> builder.setEntityResolver((publicId, systemId) -&gt; new MySafeEntityResolver(publicId, systemId)); <br />  <br /> For SAXBuilder: <br />  <br /> SAXBuilder builder = new SAXBuilder(); <br /> builder.setFeature("http://apache.org/xml/features/xinclude", true); <br /> builder.setEntityResolver((publicId, systemId) -&gt; new MySafeEntityResolver(publicId, systemId)); <br />  <br /> For SAXReader: <br />  <br /> SAXReader xmlReader = new SAXReader(); <br /> xmlReader.setFeature("http://apache.org/xml/features/xinclude", true); <br /> xmlReader.setEntityResolver((publicId, systemId) -&gt; new MySafeEntityResolver(publicId, systemId)); <br />  <br /> For XMLInputFactory: <br />  <br /> XMLInputFactory factory = XMLInputFactory.newInstance(); <br /> factory.setProperty("http://apache.org/xml/features/xinclude", true); <br /> factory.setXMLResolver(new MySafeEntityResolver()); <br />  <br /> See <br />  <br />    Oracle Java Documentation - XML External Entity Injection Attack  <br />    OWASP Top 10 2017 Category A4 - XML External <br />   Entities (XXE)  <br />    OWASP XXE Prevention Cheat <br />   Sheet  <br />    MITRE, CWE-611 - Information Exposure Through XML External Entity Reference  <br />    MITRE, CWE-827 - Improper Control of Document Type Definition  <br /> |VULNERABILITY|BLOCKER|2
Credentials should not be hard-coded|A hard-coded secret has been found in your code. You should quickly list where this secret is used, revoke it, and then change it in every system <br /> that uses it. <br /> Passwords, secrets, and any type of credentials should only be used to authenticate a single entity (a person or a system). <br /> If you allow third parties to authenticate as another system or person, they can impersonate legitimate identities and undermine trust within the <br /> organization. It does not matter if the impersonation is malicious: In either case, it is a clear breach of trust in the system, as the systems <br /> involved falsely assume that the authenticated entity is who it claims to be. The consequences can be catastrophic. <br /> Keeping credentials in plain text in a code base is tantamount to sharing that password with anyone who has access to the source code and runtime <br /> servers. Thus, it is a breach of trust, as these individuals have the ability to impersonate others. <br /> Secret management services are the most efficient tools to store credentials and protect the identities associated with them. Cloud providers <br /> and on-premise services can be used for this purpose. <br /> If storing credentials in a secret data management service is not possible, follow these guidelines: <br />  <br />    Do not store credentials in a file that an excessive number of people can access. <br />      <br />        For example, not in code, not in a spreadsheet, not on a sticky note, and not on a shared drive.  <br />        <br />    Use the production operating system to protect password access control. <br />      <br />        For example, in a file whose permissions are restricted and protected with chmod and chown.  <br />        <br />  <br /> Noncompliant Code Example <br />  <br /> import org.h2.security.SHA256; <br />  <br /> String inputString = "s3cr37"; <br /> byte[] key         = inputString.getBytes(); <br />  <br /> SHA256.getHMAC(key, message);  // Noncompliant <br />  <br /> Compliant Solution <br /> Using AWS Secrets Manager: <br />  <br /> import software.amazon.awssdk.services.secretsmanager.SecretsManagerClient; <br /> import software.amazon.awssdk.services.secretsmanager.model.GetSecretValueRequest; <br /> import software.amazon.awssdk.services.secretsmanager.model.GetSecretValueResponse; <br /> import org.h2.security.SHA256; <br />  <br /> public static void doSomething(SecretsManagerClient secretsClient, String secretName) { <br />   GetSecretValueRequest valueRequest = GetSecretValueRequest.builder() <br />     .secretId(secretName) <br />     .build(); <br />  <br />   GetSecretValueResponse valueResponse = secretsClient.getSecretValue(valueRequest); <br />   String secret                        = valueResponse.secretString(); <br />  <br />   byte[] key = secret.getBytes(); <br />   SHA256.getHMAC(key, message); <br /> } <br />  <br /> Using Azure Key Vault Secret: <br />  <br /> import com.azure.identity.DefaultAzureCredentialBuilder; <br /> import com.azure.security.keyvault.secrets.SecretClient; <br /> import com.azure.security.keyvault.secrets.SecretClientBuilder; <br /> import com.azure.security.keyvault.secrets.models.KeyVaultSecret; <br /> import org.h2.security.SHA256; <br />  <br /> public static void doSomething(SecretClient secretClient, String secretName) { <br />   KeyVaultSecret retrievedSecret = secretClient.getSecret(secretName); <br />   String secret = retrievedSecret.getValue(); <br />  <br />   byte[] key = secret.getBytes(); <br />   SHA256.getHMAC(key, message); <br /> } <br />  <br /> See <br />  <br />    AWS - Secret Manager  <br />    Azure - Key Vault  <br />    GCP - Secret Manager  <br />    Hashicorp Vault - Secret Management  <br />    OWASP Top 10 2021 Category A7 - Identification and <br />   Authentication Failures  <br />    OWASP Top 10 2017 Category A2 - Broken Authentication  <br />    MITRE, CWE-798 - Use of Hard-coded Credentials  <br />    MITRE, CWE-259 - Use of Hard-coded Password  <br />    CERT, MSC03-J. - Never hard code sensitive information  <br /> |VULNERABILITY|BLOCKER|2


## Security Hotspots

### Security hotspots count by category and priority

Category / Priority|LOW|MEDIUM|HIGH
---|---|---|---
LDAP Injection|0|0|0
Object Injection|0|0|0
Server-Side Request Forgery (SSRF)|0|0|0
XML External Entity (XXE)|0|0|0
Insecure Configuration|16|0|0
XPath Injection|0|0|0
Authentication|0|0|0
Weak Cryptography|0|0|0
Denial of Service (DoS)|0|0|0
Log Injection|0|0|0
Cross-Site Request Forgery (CSRF)|0|0|36
Open Redirect|0|0|0
Permission|0|0|0
SQL Injection|0|0|2
Encryption of Sensitive Data|0|0|0
Traceability|0|0|0
Buffer Overflow|0|0|0
File Manipulation|0|0|0
Code Injection (RCE)|0|0|0
Cross-Site Scripting (XSS)|0|0|0
Command Injection|0|0|0
Path Traversal Injection|0|0|0
HTTP Response Splitting|0|0|0
Others|10|0|0


### Security hotspots

Category|Name|Priority|Severity|Count
---|---|---|---|---
Insecure Configuration|Delivering code in production with debug features activated is security-sensitive|LOW|MINOR|9
Insecure Configuration|Creating cookies without the "secure" flag is security-sensitive|LOW|MINOR|6
Insecure Configuration|Having a permissive Cross-Origin Resource Sharing policy is security-sensitive|LOW|MINOR|1
Others|Creating cookies without the "HttpOnly" flag is security-sensitive|LOW|MINOR|5
SQL Injection|Formatting SQL queries is security-sensitive|HIGH|MAJOR|2
Others|Searching OS commands in PATH is security-sensitive|LOW|MINOR|5
Cross-Site Request Forgery (CSRF)|Allowing both safe and unsafe HTTP methods is security-sensitive|HIGH|MINOR|35
Cross-Site Request Forgery (CSRF)|Disabling CSRF protections is security-sensitive|HIGH|CRITICAL|1
